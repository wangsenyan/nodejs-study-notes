## <center>文件</center>

### 索引结点
POSIX标准
* 文件类型
* 与文件相关的硬链接个数
* 以字节为单位的文件长度
* 设备标识符(即包含文件的设备的标识符)
* 在文件系统中表示文件的索引结点号
* 文件拥有着的UID
* 文件的用户组ID
* 几个时间戳、表示索引节点状态改变的时间、最后访问时间及最后修改时间
* 访问权限和文件模式(文件所有者的用户、同组用户，不包括所有者、所有剩下的用户)
  可执行文件时
  1. suid - 进程拥有者的UID
  2. sgid - 进程组的用户组ID
  3. sticky  - 
### 文件操作的系统调用
* 打开文件 - 进程只能访问‘打开的’文件  
  `fd = open(path,flag,mode)`
  1. path 
  2. flag 指定文件打开的方式(例如，读，写，读/写，追加)，或是否创建一个不存在的文件
  3. mode - 指定新创建文件的访问权限
  4. 返回 - 打开文件+文件描述符
* 创建文件 create()
内核把文件 指针存放在打开文件对象中，即当前位置就是下一次进行读或写操作的位置
* 更改指针位置
  `newoffset =  lseek(fd, offset, whence)`
  1. fd - 表示打开文件的文件描述符
  2. offset - 指定一个有符号的整数值，用来计算文件指针的新位置
  3. whence - 指定文件指针新位置的计算方式，如 offset + 0,表示文件指针从文件头移动
     offset 加文件指针当前位置，表示从当前位置移动，offset加文件最后一字节的位置，表
     示文件指针从文件末尾开始移动
* 读文件
  `nread = read(fd, buf, count)`
  1. fd - 打开文件的文件描述符
  2. buf - 指定在进程地址空间中缓存区的地址，所读的数据就放在这个缓冲区
  3. count - 所读的字节数
* 关闭文件
  `res = close(fd)`
* 更名
  `res = rename(oldpath,newpath)`
* 删除文件
  `res = unlink(pathname)`
### 进程/内核模式(CPU)
* 用户态
  不能直接访问内核数据结构或内核的程序
* 内核态
* 用户进程

* 内核线程 特权进程
 1. 它们以内核态运行在内核地址空间
 2. 它们不与用户直接交互，因此不需要终端设备
 3. 它们通常在系统启动时创建，然后一直处于活跃状态知道系统关闭
* 单处理系统 - 任何时候只有一个进程在运行
* 内核例程激活方式 
  1. 进程调用系统调用
  2. 正在执行的CPU发出一个异常信号
  3. 外围设备向CPU发出一个中断信号以通知一个事件的发生，每个中断信号都是由内核中的中断处理程序来处理(interrupt handler)
  4. 内核线程被执行
* 进程实现 - 进程描述符(process descriptor)
  当内核暂停一个进程的执行时，就把几个相关处理器寄存器的内容保存在进程描述符中，这些寄存器包括:  
  * 程序计数器(PC)和栈指针(SP)寄存器
  * 通用寄存器
  * 浮点寄存器
  * 包含CPU状态信息的处理器控制寄存器(处理器状态字，processor status word)
  * 用来跟踪进程对RAM访问的内存管理寄存器
  当内核决定恢复执行一个进程时，它用进程描述符中合适的字段来装载CPU寄存器。
* 可重入内核
* 内核控制路径(kernel control path) - 表示内核处理系统调用、异常或中断所执行的指令序列。
* 进程地址空间  
  每个进程运行在它的私有地址空间(私有栈、数据区、代码区)  
  mmap()系统调用，该系统调用允许存放在块设备上的文件或信息的一部分映射到进程的部分地址空间。
* 同步和临界区 - 实现可重入需要利用同步机制
  当某个计算结果取决于如何调度两个或多个进程时，相关代码就是不正确的。
* 原子操作 和 临界区
* 信号和进程间通信
  信号(signal)系统事件报告给进程的一种机制  
  系统事件:  
  1. 异步通告
  2. 同步错误或异常
  进程可以以两种方式对接收到的信号做出反应:
  1. 忽略改信号
  2. 异步的执行一个指定的过程(信号处理程序)
  如果进程不指定选择何种方式，内核就根据信号的编号执行一个默认操作，五种
  1. 终止进程
  2. 将执行上下文和进程地址空间的内容写入一个文件，并终止进程
  3. 忽略信号
  4. 挂起进程
  5. 如果进程曾被暂停，则回复它的执行
 System V IPC:信号量，消息队列及共享内存
 内核把它们作为IPC资源来实现:进程要获得一个资源，可以调用shmget()、semget()或msgget()
 IPC资源是持久不变的，进程创建者、进程拥有者或超级用户进程必须显示的释放这些资源
  1. msgsnd() - 把消息插入大指定的队列中
  2. msgget() - 从队列提取消息
  3. shmat()  - 创建一个新的共享内存
  4. shmdt()  - 将共享内存从其地址空间分离出去
  3. 信号量 - 类型同步临界区，在用户进程中
* 进程管理
 1. `fork()`  - 创建一个新进程
 2. `_exit()` - 终止一个进程
 3. `exec()`  - 装入一个新程序
* 僵死进程(zombie process)
  `wait4()`系统调用允许进程等待，直到其中的一个子进程结束，返回已终止子进程的进程标识符(PID)
* 进程组合登录会话
### 内存管理
* 虚拟内存
 `应用程序内存请求 - 虚拟内存(virtual memory) - 硬件内存管理单元(Memory Management Unit,MMU)`
* 虚拟内存子系统的主要成分是`虚拟地址空间(virtual address space)`的概念
* 随机访问存储器(RAM)的使用
* 内存碎片 - 物理内存不连续之间的空隙
* 内核内存分配器(kernel memory allocator,KMA)
* 进程虚拟地址空间处理
  进程的虚拟地址空间包括了进程可以引用的所有虚拟内存地址。内核通常用一组内存去描述进程虚拟地址空间。例如，当进程通过exec()类系统调用开始某个程序的执行时，内核分配给进程的虚拟地址空间由以下内存去组成:
  1. 程序的可执行代码
  2. 程序的初始化数据
  3. 程序的未初始化数据
  4. 初始程序栈(即用户态栈)
  5. 所需共享库的可执行代码和数据
  6. 堆(由程序动态请求的内存)
