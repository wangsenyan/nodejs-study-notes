### 注意点
* 编译器不会检查使用的下标是否有效。比如定义a[10]但赋值a[10]=11,溢出
* sizeof 用于数组名得到的是整个数组中的字节数
* 初始化数组时，可省略等号 =
* 列表初始化禁止缩窄转换
* 字符常量不能与字符串常量互换，'S'为83,"S"为 'S'和'\0',实际为字符串所在的内存地址;
* 空白：空格，制表符，换行符
* cin.getline(name,strlen)将丢弃换行符,get()将换行符保留在输入序列中
* cin.get(name,strlen).get()
  cin.get(dessert,strlen)
* C++允许函数有多个版本，条件是这些版本的参数列表不同
* get()空行后设置失效位，接下来的输入将被阻断，可用cin.clear()恢复
* cin>>number 会将换行符留在里面 (cin>>number ).get()
* getline() 入股输入行包含的字符数比指定的多这设置失效位，关闭后面的输入
* get() 空行失效位   多保存剩余继续  保存换行符
  getline()空行继续  多失效位  丢弃换行符

* 数组不能赋值但string可以
* 未初始化的数组内容是未定义的，其次，函数strlen()从数组的第一个元素开始计算字节数，直到遇到空字符
* 未被初始化的string对象长度设置为0 getline(cin,str)
* wchar_t title[]=L"agagafg";  
  char16_t name[]=u"agafgag";  
  char32_t car[]=U"nagagfafg";  

* raw字符串，用"()"作定界符，前缀R  
  R"(Jim "king" Tutt uses "\n" instead of endl.)"  
  R"+\*("(who would't?)",she whispered.)+\*"  
  " 和 ( 或 )之间的(包括"()")字符表示界定符
* 不能直接输出 结构体

```c++
//定义结构，创建结构变量和初始化结构变量
struct inflatable
{
  char name[20];
  float volume;
  double price;
};
struct perks
{
  int key_number;
  char car[12];
} mr_glits{7, "Packard"};
inflatable gifts[100]; //结构数组  
```
* 结构中的位字段

```c++
struct torgle_register
{
  unsigned int SN : 4;
  unsigned int : 4;
  bool goodIn : 1;
  bool goodTorgle : 1;
};
```
* 共同体
匿名共同体-其成员将成为位于相同地址处的变量
```cpp
struct widget
{
  char brand[20];
  int type;
  union {
    long id_num;
    char id_char[20];
  };
};
widget prize;
if(prize.type==1)
	cin>>prize.id_num;
else
	cin>>prize.id_char;
```
* 枚举 enum
只定义了赋值运算符，么有定义算数运算符
可以转换为int但int不可以转化为枚举类型

* new,delete
  - 不要用delete释放不是new分配的内存
  - 不要使用delete释放同一个两个内存两次
  - new [] 用delete 【】释放
  - 对空指针delete释放是安全的
  - 不能用sizeof 确定动态分配的数组包含的字节数
```cpp
int * psome=new int [10];
delete [] psome;
```
* C++将数组名解释为地址
* 对数组名取地址
```cpp
short tell[10];
tell+1 //将地址加2，&tell[0]是一个2字节内存地址的地址
&tell+1 //将地址加20，&tell是一个20字节内存块地址
```

* 变量类型
  - 不支持对自动数组和自动结构的初始化
  - 为什么无法访问自由存储空间中的结构？？？指针为何无效

* 数组名是指针，数组成员是变量，n_elem可以是变量
* 模板内vector - vector<int>vi --类似强制类型转换
  ```cpp
  #include <vector>
  vector<typeName> vt(n_elem)
  ```
* 模板类array,n_elem不能是变量
  ```cpp
  #include<array>
  using namespace std;
  array<typeName,n_elem> arr;
  ```
  