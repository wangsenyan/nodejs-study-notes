### 函数
* 如果实参与引用参数不匹配，C++将生成临时变量，当前仅当参数为const引用时，C++才允许这样做。
 - 实参的类型正确，但不是左值
 - 实参的类型不正确，但可以转化为正确的类型
* 常规变量和const变量都可视为左值，因为可通过地址访问它们
* 临时变量需要类型和命名，否则临时变量

#### 引用参数
* 实际上是基于指针的代码的另一个接口
* 对象是数组，只能使用指针
* 引用不可以做数组中的元素 比如int& b[3]，但允许
int (&b)[3]

### 默认参数
当函数调用中省略了实参时自动使用的一个值
* `char *left(const char *str,int n=1);`
* 必需从右向左提供默认值，实参按从左到右的顺序依次被赋给相应的形参，而不能跳过任何参数

#### 函数重载
函数重载的关键是函数的参数列表-函数特征标
* 没有匹配，尝试使用标准类型转换强制进行匹配(仅有一个原型)
* double 与double &x 同
即编译器在检查函数特征标时，将把类型引用和类型本身视为同一个特征标  
不区分const和非const变量(限一个原型)  
将非const值赋给const变量是合法的，相反是非法的
* 是特征标而不是函数类型

#### 函数模板
通过将类型作为参数传递给模板，可以编译器生成该类型的函数
* 基本定义
```cpp
template <typename AnyType>
//template <class AnyType>
void Swap(AnyType &a,AnyType &b)
{
	AnyType temp;
	temp=a;
	a=b;
	b=temp;
}
```
* 最后生成独立的函数定义