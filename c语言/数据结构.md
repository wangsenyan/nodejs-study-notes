### 翻译单元
   编译后的单元，包含#include,全局变量
### 链接
 外部链接、内部链接、无链接
 无链接:具有块作用域、函数作用域或函数原型作用域的变量都是(私有)
 外部链接:具有文件作用域，可以被多个文件程序使用
 内部链接:具有文件作用域，只能在一个翻译单元中使用static
### 存储期
  静态存储期 程序执行期间一直存在，函数内的静态对象，可以给出地址被其他程序使用
  线程存储期
  自动存储期
  动态分配存储期
    变长数组：从声明处到快的末尾（函数原型）
### 块级作用域
```分别在各块中定义n，后面的屏蔽前面的块
#include <stdio.h>
int main(){
    int n = 8;
    printf("Initially,n=%d at %p\n",n,&n);
    for(int n =1;n<3;n++)
        printf("loop 1:n=%d at %p\n",n,&n);
    printf("After loop 1,n=%d at %p\n",n,&n);
    for(int n =1;n<3;n++){
        printf("loop 2 index n=%d at %p\n",n,&n);
        int n=6;
        printf("loop 2:n=%d at %p\n",n,&n);
        n++;
    }
    printf("After loop 2:n=%d at %p\n",n,&n);
    return 0;
}
```
```
Initially,n=8 at 0061FF2C
loop 1:n=1 at 0061FF28
loop 1:n=2 at 0061FF28
After loop 1,n=8 at 0061FF2C
loop 2 index n=1 at 0061FF24
loop 2:n=6 at 0061FF20
loop 2 index n=2 at 0061FF24
loop 2:n=6 at 0061FF20
After loop 2:n=8 at 0061FF2C
```
###变量
   自由变量：不会自动初始化（块级作用域、无链接、自动存储期）
   寄存器变量：无法获取寄存器变量的地址 register
   静态变量：该变量在内存中原地不动，并不是值不变，只在第一次初始化，如果未显式初始化，会被初始化为0
```程序跳过了static int stay=1;静态变量和外部变量在程序被载入内存时已经执行完毕。这条声明放在trystat()函数中是告诉编译器只有trystat()函数才能看到该变量。这条声明并未在运行时执行
#include <stdio.h>
void trystat(void);
int main(void)
{
    int count;
    for(count=1;count<=3;count++)
    {
       printf("Here comes iteration %d.\n",count);
       trystat();
    }
}
void trystat(void)
{
    int fade =1;
    static int stay = 1;
    printf("fade=%d and stay = %d\n",fade++,stay++);
}
```
   外部链接的静态变量：int a，在块中 不用声明或者 extern int a,不能int a,这样会屏蔽外层
   外部变量：初始化，只能用常量表达式

### 数据结构
   * 虽然结构不能含有与本身类型相同的结构，但是可以含有指向同类型结构的指针。
   * malloc() 检查是否成功请求到内存

### 抽象数据类型(ADT)
   * 类型特质属性和操作
   * 首先，提供存储数据的方法
   * 其次，提供操控数据的方法
   * 定义新类型
     1. 提供类型属性和相关操作的抽象描述，这些描述既不能依赖特定的实现，也不能依赖特定的编程语言，这种正式的抽象描述被称为抽象数据类型(ADT)
     2. 开发一个实现ADT的编程接口。指明如何存储数据和执行所需操作的函数。
     3. 编写代码实现接口。
     ···
     类型名:
     类型属性:
     类型操作:
     ···
  *  typedef 为复杂的声明定义简单的别名，不能与auto/extern/mutable/static/register等关键字出现在同一个表达式中
     typedef int size;将int定义为size别名

### 树
  * 结点
    包含一个数据元素及若干指向其子树的分支，拥有的指数称为结点的度

### 赫夫曼树
  * 扩充二叉树
    添加新结点，使得原有的所有结点的度都为二  
    原有的结点为内结点  
    新增的结点为外结点  
    外结点数 = 内结点数 +1  
    总结点数 = 2*外结点数 +1  

  * 赫夫曼树的外结点和内结点  
    外结点携带了关键数据的结点，内部结点没有，只作为导向最终的外结点所走的路径二使
```
          n
    WPL = ∑ WkLk
         n=1
```
    同一组权值叶节点，构成的赫夫曼树可以有多种形态，但是 最小WPL值是唯一的
  * 路径长度
    从树中一个结点到另一个节点之间的分支构成这两个结点之间的路径，路径上分支数目为路径长度
  * 树的路径长度
    树根带每一个结点的路径才读之和
  * 前缀编码 
    要设计长短不等的编码，必须保证，任意一个字符的编码都不是另一个字符编码的前缀
    赫夫曼编码就是前缀编码
  * 

### 递归简论
   当一个函数用自己来定义时就称为是递归
   递归法则:假设所有的递归调用都能运行
   
   * 基准情形
   * 不断推进
   * 设计法则 - 假设所有的递归调用都能运行
   * 合成效益法则 - 在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作
### 算法
  **算法是为求解一个问题需要遵循的、被清楚的指定的简单指令的集合**
  * 伪代码一些约定
    1. 缩进表示快结构
    2. 退出循环后循环计数器保持其值
    3. // 表示注释
    4. i=j=e 多重赋值表达式
    5. 无显示说明，不使用全局变量
    6. 复合数据通常被组织成对象，对象又由属性组成
    7. 把表示一个数组或对象的变量看做是指向表示数组或对象的数据的一个指针
    8. 按值把参数传递给过程，即被调用过程接受参数自身的副本
    9. return 将控制返回调用过程的调用点
    10. and or 都是短路的
    11. 通过位左移实现指数运算 的常量时间的 操作
    12. 通常把一个程序的运行时间描述成其输入规模的函数
    13. 输入规模
    14. 运行时间 - 一个算法在特定输入上的运行时间是指执行的基本操作或步数
    15. 最坏情况运行时间
    16. 忽略低阶项和最重要的项的常系数
#### 分治法(归并排nlgn) < 插入排序 n*n
  1. 分解
  2. 解决
  3. 合并 - MERGE(A,p,q,r) A是一个数组，p,q,r是数组下标，满足 $p<=q<r$; n=r-p+1 待合并元素的总数
  对于n个数(n为2的整数幂)，分解lg(n)层，每层 排序合并时间为 cn,总共cnlgn
  T(n) = { c 若 n=1; 2T(n/2)+cn 若n>1;

### 函数的增长
  1. 渐进记号 Θ 渐进确界
     $Θ(g(n))={f(n)$:存在正常量c1,c2和n0,使得对所有n≥n0，有0≤c1g(n)≤f(n)≤c2g(n)}
  2. Θ(g(n)) 的定义要求每个成员f(n)∈Θ(g(n))均渐进非负，因此，g(n)本身必为渐进非负
  3. $y = an^2 + bn + c$
     y = (n+b/(2a))^2+(4ac-b^2)/(4a^2)
                  d
  4. 对任意p(n) = ∑ ain^i ，ad >0,有p(n) = Θ(n^d)
                 i=0
  5. 当只有一个渐进上界时，使用 O 记号
     O(g(n)) = {f(n):存在正常量c和n0,使得对所有n≥n0,有0≤f(n)≤cg(n) }
     f(n) = O(g(n)) 指出函数f(n)是集合O(g(n))的成员
     n = O(n^2)
  6. 上界和确界，上界确定最坏情况，如插入排序，如排序好后，Θ(n)，最坏为Θ(n^2) ，确界确定最好最坏情况
  7. Ω 渐进下界
     Ω(g(n))={f(n):存在正常量c和n0,使得对所有n≥n0,有0≤cg(n)≤f(n)}

### 二叉树
* 关系
* [阿克曼函数](https://baike.baidu.com/item/%E9%98%BF%E5%85%8B%E6%9B%BC%E5%87%BD%E6%95%B0)`A(x)=A(x,x)` - 非原始递归函数的例子，需要两个自然数作为输入值，输出一个自然数，它的输出值增长速度非常高，仅是对于(4,3)的输出已经大得不能准确计算。  
  它的反函数α(x)定义为最大的整数m使得Ackermann(m,m)<=x。因为Ackermann函数的增长很快，所以其反函数α(x)的增长是非常慢的，对所有在实际问题中有意义的x，α(x)≤4，所以在算法时间复杂度分析等问题中，可以把α(x)看成常数。
* 拟逆 - 反函数