## <center>名字与地址转换</center>
* gethostbyname 主机名映射为IPv4地址
* gethostbyaddr IPv4地址映射为主机名
* getservbayname
* getservbyport
* getaddrinfo
* getnameinfo

### 域名系统
* DNS 主机名字与IP地址之间的映射
* FQDN 全限定域名 
* RR(resource record) 资源记录
  - A A记录把一个主机名映射成一个32位的IPV4地址。
  - AAAA(四A) 把一个主机名映射成一个128位的IPv6地址
  - PTR 指针记录把IP地址映射成主机名
    - 对IPv4地址，32位地址的4个字节先反转顺序，每个字节都转换成各自的十进制ASCII值，再添加上 in-addr.arpa,用于PTR查询
    - 对IPv6地址，128位地址中的32个4位组先反转顺序，每个个四位组都被转换成相应的十六进制ASCII值，再添加ip6.arpa
  - MX 把一个主机指定作为给定主机的“邮件交换器(max exchanger)”,当存在多个MX记录时，它们按照优先级顺序使用，值越小优先级越高
  - CNAME (canonical name) 规范名字，为常用服务指派CNAME记录
```
12.106.32.254   --->   254.32.106.12.in-addr.arpa
3ffe:b80:1f8d:1:a00:20ff:fea7:686b    --->
b.6.8.6.7.a.e.f.f.f.0.2.0.0.a.1.d.8.f.1.0.8.b.e.f.f.3.ip6.arpa
```

* 解析器和名字服务器
  - BIND 名字服务器
  - 应用进程、解析器和名字服务器
  - 解析器代码通过读取其系统相关配置文件确定本组织机构的名字服务器们所在位置。
  - 文件 /etc/resolv.conf通常包含本地名字服务器主机的IP地址
  - 如果答案太长，超出UDP消息的承载能力，本地名字服务器和解析器会自动切换到TCP
![addr_name](../../image/addrname.png)

* DNS替代方法
  - 常用替代方法有静态主机文件(/etc/hosts)、网络信息系统(Network Information System,NIS) 以及轻权目录访问协议(Lightweight Directory Access Protocol,LDAP)

* gethostbyname 函数
  - 执行的是对A记录的查询，只返回IPv4地址
  - 发生错误时，它不设置errno值，而是将全局整数变量 h_errno 设置为在头文件 <netdb.h>中定义常值之一
  - NO_DATA 表示指定的名字有效，但是没有A记录
```c
#include <netdb.h>
#define HOST_NOT_FOUND
#define TRY_AGAIN
#define NO_RECOVERY
#define NO_DATA
struct hostent{
  char *h_name;      // official (canonical) name of host
  char **h_aliases;  //pointer to array of pointers to alias names
  int h_addrtype;    //host address type:AF_INET
  int h_length;      //length of address:4
  char **h_addr_list //ptr to array of ptrs with IPv4 addrs
}

struct hostent *gethostbyname(const char *hostname);
//返回：若成功则为非空指针，若出错则为NULL且设置h_errno
```
[hostent](../hostent.c)

* gethostbyaddr函数
  - 二进制的IP地址找到相应的主机名
  - addr实际上不是char *类型，而是一个指向存放IPv4地址的某个in_addr结构的指针，len是这个结构的大小，对于IPv4，family参数为AF_INET
  - gethostbyaddr在in_addr.arpa域中向一个名字服务器查询PTR记录 
```c
#include <netdb.h>
struct hostent *gethostbyaddr(const char *addr,socklen_t len,int family);
//返回：若成功则为非空指针，若出错则为NULL且设置h_errno
```

* getservbyname 和 getservbyport 函数
  - 从名字到端口号的映射关系保存在一个文件中(通常是 /ect/services)
  - 端口号以网络字节返回的，把它存放到套接字地址结构时绝对不能调用htons
  - grep -e ^ftp -e ^domain /etc/services
  - getservbyport用于根据端口号和可选协议查找相应服务
  - getservbyport port参数的值必须为网络字节序
  - grep 512 /etc/services
```c
#include <netdb.h>
struct servent {
  char *s_name;    //official service name
  char **s_aliases;//alias list
  int s_port;      //port number,network byte order
  char *s_proto;   //protocol to use
};

struct servent *getservbyname(const char *servname,const char *protoname);
//返回：若成功则为非空指针，若出错则为NULL
struct servent *sptr;
sptr = getservbyname("domain","udp"); //dns using udp
sptr = getservbyname("ftp","tcp");    //ftp using tcp
sptr = getservbyname("ftp",NULL);
sptr = getservbyname("ftp","udp");    //this call with fail

struct servent *getservbyport(int port,const char *protoname);
//返回：若成功则为非空指针，若出错则为NULL
sptr = getservbyport(htons(53),"udp"); //DNS using UDP
sptr = getservbyport(htons(21),"tcp"); //FTP using TCP
sptr = getservbyport(htons(21),NULL);  //FTP using TCP
sptr = getservbyport(htons(21),"udp"); //this call with fail
```

[daytimetcpcli](../daytimetcpcli.c)

* getaddrinfo 函数 
  - 通过result指针参数返回一个指向addrinfo结构链表的指针
```c
#include <netdb.h>
struct addrinfo{
  int ai_flags; //AI_PASSIVE,AI_CANONNAME
  int ai_family;//AF_xxx
  int ai_socktype; //SOCK_xxx
  int ai_protocol; //0 or IPPROTO_xxx for ipv4 and ipv6
  socklen_t ai_addrlen;//length of ai_addr
  char *ai_canonname;//ptr to canonical name for host
  struct sockaddr *ai_addr;
  struct addrinfo *ai_next;
}

int getaddrinfo(const char *hostname,const char *service,const struct addrinfo *hints,struct addrinfo **result);
//返回：若成功则为0，若出错则为非0
```
